#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>


#define BUFFER_SIZE 10  //defining circular buffer size
#define MAX_INTEGER 100   //number of integers producer will produce

int buffer[BUFFER_SIZE];
int head = 0;  // to keep track of the index where next generated integer is to be added in buffer
int tail = 0;  // to keep track of the index of the buffer from where the integer is to be consumed
int num_of_integers_produced = 0;  //keeps track of no of integers produced,will increment till 100
int num_of_integers_consumed = 0;  //keeps track of no of integers consumed,will increment till 100
int a=0,b=0; //a is a variable used by producer to generate in a sequence, b denotes serial number of integers printed by consumer threads

sem_t empty, full, mutex; //three semaphores to achieve mutual exclusion and synchronization

//producer function will produce integers between 1 and 100(included)
//thread will return upon generating 100 integers

void* producer(void* arg) {
    int max_integers = *(int*) arg;

    //will iterate till producing 100 integers
    
    while (num_of_integers_produced < max_integers) {
        int item = ++a; // Generates integer in a sequential order from 1 to 100

        sem_wait(&empty);  //waits for buffer to be empty
        sem_wait(&mutex);  //mutual exclusion for entering critical section,that is, writing in buffer

        //adds new item to the buffer and updates the head index and incements the no of produced integers
        buffer[head] = item;
        head = (head + 1) % BUFFER_SIZE;
        num_of_integers_produced++;

        sem_post(&mutex); //releases lock,exits critical section
        sem_post(&full);  //signals full semaphore
    }

    return NULL;  //returns to main thread upon generating required no of integers
}


//consumer function-each thread will consume the items from buffer
//threads will return upon consuming 100 integers produced by the producer

void* consumer(void* arg) {
    
    
    //will iterate till producing 100 integers
    
    while (num_of_integers_consumed < MAX_INTEGER) {
        sem_wait(&full);  //waits if buffer is full
        sem_wait(&mutex); //mutual exclusion for entering critical section,that is, reading in buffer

        //consumes item from the buffer and updates the tail index and increments the no of consumed integers
        int item = buffer[tail];
        tail = (tail + 1) % BUFFER_SIZE;
        num_of_integers_consumed++;

        sem_post(&mutex);  //releases lock,exits critical section
        sem_post(&empty);  //signals empty semaphore

        printf("Serial number:%d        Consumed Integer:%d\n",++b,item); //prints the read item by thread and the serial number of consumed integer
    }

    return NULL;  //returns to main thread upon integers all integers generated by producer
}

int main(int argc, char** argv) {  //argc and argv are command line arguments
   
    int max_integers = MAX_INTEGER;  //initializes the variable

    if (argc > 1) {
        max_integers = atoi(argv[1]);
    }

    sem_init(&empty, 0, BUFFER_SIZE); //initializes semaphore equal to the size of buffer
    sem_init(&full, 0, 0);  //initializes semaphore equal to 0
    sem_init(&mutex, 0, 1);  //initializes semaphore equal 1

    pthread_t producer_thread;   // 1 producer thread
    pthread_create(&producer_thread, NULL, producer, &max_integers);  //creates producer thread

    pthread_t consumer_threads[BUFFER_SIZE];  //creates 10 consumer threads
    for (int i = 0; i < BUFFER_SIZE; i++) {
        pthread_create(&consumer_threads[i], NULL, consumer, NULL);
    }

    pthread_join(producer_thread, NULL);   //waits for the producer thread to exit
    for (int i = 0; i < BUFFER_SIZE; i++) {
        pthread_join(consumer_threads[i], NULL);   //waits for all consumer threads to exit
    }

    
    //destroys all semaphores created
    
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);

    return 0;  //exits the main function
}

